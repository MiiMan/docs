---
title: 4. Библиотеки виджетов
description: В этом параграфе мы рассмотрим виджеты, входящие в состав стандартных библиотек Flutter.
author: Геннадий Альхеев
tableOfContents: false
---
# Оглавление

- [Введение](#%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5)
- [Фундамент](#%D0%A4%D1%83%D0%BD%D0%B4%D0%B0%D0%BC%D0%B5%D0%BD%D1%82)
	- [MaterialApp](#materialapp)
	- [Scaffold](#scaffold)
- [Содержимое](#%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B8%D0%BC%D0%BE%D0%B5)
	- [Text](#text)
	- [Icon](#icon)
	- [Image](#image)
	- [GestureDetector, InkWell](#gesturedetector-inkwell)
	- [TextField, Button](#textfield-button)
	- [SnackBar](#snackbar)
- [Расположение](#%D0%A0%D0%B0%D1%81%D0%BF%D0%BE%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5)
	- [Column, Row, Stack](#column-row-stack)
	- [SingleChildScrollView](#singlechildscrollview)
	- [ListView](#listview)
	- [SizedBox](#sizedbox)
	- [Padding](#padding)
	- [SafeArea](#safearea)
- [Декорация](#%D0%94%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%86%D0%B8%D1%8F)
	- [Container](#container)
- [Заключение](#%D0%97%D0%B0%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5)

## Введение

В этом параграфе мы рассмотрим некоторые виджеты, входящие в состав стандартных библиотек Flutter.

Во Flutter есть три библиотеки, предоставляющие основные виджеты:

- **[Widgets library](https://api.flutter.dev/flutter/widgets/widgets-library.html)** — общие виджеты, внешний вид которых не привязан к конкретной платформе. Например, текстовые виджеты, виджеты для позиционирования, отображения списков и прочие.
- **[Material library](https://api.flutter.dev/flutter/material/material-library.html)** — виджеты, стилизованные под [гайдлайны Material Design](https://m3.material.io/) от Google.
- **[Cupertino library](https://api.flutter.dev/flutter/cupertino/cupertino-library.html)** — виджеты, стилизованные под [гайдлайны Apple](https://developer.apple.com/design/human-interface-guidelines).

Помимо виджетов, представленных в этом параграфе, существует ещё множество других. С ними можно ознакомиться через каталог виджетов из [официальной документации](https://docs.flutter.dev/ui/widgets).

Мы будем рассматривать в основном компоненты из библиотек `widgets` и `material`. У большинства виджетов из `material` существуют аналоги из `cupertino`, с которыми вы можете ознакомиться самостоятельно.

## Фундамент

### MaterialApp

Вы часто можете встретить [`MaterialApp`](https://api.flutter.dev/flutter/material/MaterialApp-class.html) в качестве виджета, передающегося в функцию `runApp`. Этот виджет закладывает основу приложения. Он управляет навигацией, темизацией, локализацией приложения и прочей базовой функциональностью. Ниже вы можете посмотреть пример использования этого виджета:

```dart
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      themeMode: ThemeMode.dark,
      theme: ThemeData.light(useMaterial3: true),
      darkTheme: ThemeData.dark(useMaterial3: true),
      debugShowCheckedModeBanner: false,      
      home: MyWidget(),
    );
  }
}

class MyWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Text(
          'Hello, World!',
          style: Theme.of(context).textTheme.headlineMedium,
        ),
      ),
    );
  }
}
```

В данном примере при помощи `MaterialApp` мы задали следующую конфигурацию приложения:

- **Темы:** Задали светлую и тёмную темы с использованием стилей из [Material 3](https://m3.material.io/) (актуальной версии Material Design).
- **Тема приложения:** Включили использование тёмной темы всегда, вместо синхронизации с темой устройства.
- **Отображение дебаг-подписи:** Выключили отображение дебаг-подписи в углу экрана. Помимо параметра `debugShowCheckedModeBanner` есть и другие debug-параметры, которые могут быть полезны при разработке. С ними вы можете ознакомиться в документации.
- **Параметр `home`:** Определили начальный виджет приложения — `MyWidget`.

Несмотря на название, `MaterialApp` адаптирует внешний вид приложения в зависимости от того, на какой ОС запущено приложение. Например, поведение скролла и анимация переключения страниц будут отличаться на Android и iOS.

Помимо `MaterialApp` существует виджет [`CupertinoApp`](https://api.flutter.dev/flutter/cupertino/CupertinoApp-class.html). Он предоставляет такую же функциональность, но повторяет поведение нативных iOS-приложений, независимо от платформы запуска.

Стоит отметить, что и `MaterialApp`, и `CupertinoApp` под капотом используют [`WidgetsApp`](https://api.flutter.dev/flutter/widgets/WidgetsApp-class.html), в котором разработчики Flutter инкапсулировали общую логику. Если вы захотите получить больше контроля над различными параметрами приложения, вы можете использовать `WidgetsApp` самостоятельно.

Если вы посмотрите на исходный код виджетов, описанных выше, вы увидите, что они являются композицией множества других виджетов, каждый из которых отвечает за свою функциональность. Например, за навигацию отвечают виджеты `Navigator` и `Router`, за тему — `AnimatedTheme` и другие.

### Scaffold

[`Scaffold`](https://api.flutter.dev/flutter/material/Scaffold-class.html) представляет собой страницу приложения и реализует основную структуру экрана. В простейшем виде в `Scaffold` можно указать единственный параметр `body` — виджет содержимого страницы. Но у него есть и другие параметры.

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(MaterialApp(
    theme: ThemeData.light(useMaterial3: true),
    home: const ScaffoldExample(),
  ));
}

class ScaffoldExample extends StatelessWidget {
  const ScaffoldExample({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('App Bar title'),
      ),
      body: const Center(
        child: Text('Content'),
      ),
      bottomNavigationBar: BottomAppBar(
        shape: const CircularNotchedRectangle(),
        child: Container(height: 50.0),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {},
        child: const Icon(Icons.bolt),
        shape: CircleBorder(),
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
    );
  }
}
```

Благодаря `Scaffold` мы смогли использовать виджеты [`AppBar`](https://api.flutter.dev/flutter/material/AppBar-class.html), [`BottomAppBar`](https://api.flutter.dev/flutter/material/BottomAppBar-class.html), [`FloatingActionButton`](https://api.flutter.dev/flutter/material/FloatingActionButton-class.html), и при этом нам не пришлось заботиться об их размещении на экране. `Scaffold` значительно упрощает использование базовых элементов интерфейса и позволяет быстро реализовать интерфейс, соответствующий стандартам Material Design.

А сейчас давайте вернёмся к предыдущему примеру и внимательно посмотрим на результат его работы:

```dart
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      themeMode: ThemeMode.dark,
      theme: ThemeData.light(useMaterial3: true),
      darkTheme: ThemeData.dark(useMaterial3: true),
      debugShowCheckedModeBanner: false,      
      home: MyWidget(),
    );
  }
}

class MyWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Text(
          'Hello, World!',
          style: Theme.of(context).textTheme.headlineMedium,
        ),
      ),
    );
  }
}
```

По аналогии с `MaterialApp`, у `Scaffold` тоже есть аналог в Cupertino-стиле — [`CupertinoPageScaffold`](https://api.flutter.dev/flutter/cupertino/CupertinoPageScaffold-class.html). Он используется реже, так как не предоставляет такой же гибкости.

## Содержимое

### Text

Виджет [`Text`](https://api.flutter.dev/flutter/widgets/Text-class.html) позволяет отобразить текстовое содержимое с определённым стилем.

```dart
import 'package:flutter/material.dart';

const loremIpsum =
    'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.';

class TextExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return const Text(
      loremIpsum,
      textAlign: TextAlign.center,
      overflow: TextOverflow.ellipsis,
      maxLines: 2,
      style: TextStyle(
        color: Colors.teal,
        fontSize: 15,
        fontWeight: FontWeight.bold,
      ),
    );
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: Center(
          child: SizedBox(
            width: 200,
            child: TextExample(),
          ),
        ),
      ),
    );
  }
}
```

Мы использовали некоторые параметры:

- **`textAlign`** — расположение текста внутри виджета.
- **`overflow`** — определяет поведение виджета, если размер текста превышает размеры виджета.
- **`maxLines`** — максимальное количество строк, которое может вместить виджет.
- **`style`** — объект, задающий стиль текста.

Остановимся немного подробнее на стиле текста. За добавление стандартного стиля отвечает виджет `Material`, скрытый внутри `MaterialApp`. Информацию о нужном стиле `Material` берёт из темы и передаёт её тексту при помощи механизма `InheritedWidget`.

[`DefaultTextStyle`](https://api.flutter.dev/flutter/widgets/DefaultTextStyle-class.html) отвечает за передачу стиля текста по умолчанию. Вы сами можете его использовать, иногда это может быть удобно для отображения блоков с большим количеством текстовых виджетов с общим стилем.

```dart
import 'package:flutter/material.dart';

const loremIpsum =
    'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.';

class TextExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return DefaultTextStyle.merge(
      maxLines: 4,
      style: const TextStyle(
        fontSize: 24,
        fontWeight: FontWeight.bold,
      ),
      child: const Text(
        loremIpsum,
        textAlign: TextAlign.center,
        overflow: TextOverflow.ellipsis,
        style: TextStyle(
          color: Colors.red,
        ),
      ),
    );
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: Center(
          child: SizedBox(
            width: 200,
            child: TextExample(),
          ),
        ),
      ),
    );
  }
}
```

В данном примере используется статичный метод [`DefaultTextStyle.merge`](https://api.flutter.dev/flutter/widgets/DefaultTextStyle/merge.html). Он объединяет переданный ему стиль с родительским дефолтным стилем. Аналогично при передаче параметра `style` в `Text` различные свойства объединяются.

Также существует расширенная версия текстового виджета — [`RichText`](https://api.flutter.dev/flutter/widgets/RichText-class.html). Он позволяет отображать форматированный текст, то есть использовать разные стили внутри одного виджета и даже, например, обрабатывать нажатия, имитируя ссылки. Подробнее с `RichText` вы можете ознакомиться в [документации](https://api.flutter.dev/flutter/widgets/RichText-class.html).

### Icon

[`Icon`](https://api.flutter.dev/flutter/widgets/Icon-class.html) позволяет отображать векторные иконки. У них можно задавать размер, цвет и некоторые другие параметры:

```dart
import 'package:flutter/material.dart';
import 'package:flutter/cupertino.dart';

class IconExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return const Row(
      mainAxisAlignment: MainAxisAlignment.spaceAround,
      children: [
        Icon(Icons.alarm),
        Icon(
          Icons.favorite,
          color: Colors.pink,
          size: 36.0,
          semanticLabel: 'Text to announce in accessibility modes',
        ),
        Icon(
          CupertinoIcons.battery_25,
          color: Colors.green,
          size: 24.0,
        ),
      ],
    );
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: Center(
          child: IconExample(),
        ),
      ),
    );
  }
}
```

Главный вопрос — откуда брать иконки и как создавать свои. В `material` и `cupertino` библиотеках уже есть довольно обширные наборы, которые находятся в классах [`Icons`](https://api.flutter.dev/flutter/material/Icons-class.html) и [`CupertinoIcons`](https://api.flutter.dev/flutter/cupertino/CupertinoIcons-class.html). Чтобы использовать эти классы в вашем проекте, необходимо добавить их в `pubspec.yaml`:

```yaml
# ...
dependencies:
  cupertino_icons: ^1.0.0
# ...
flutter:
  uses-material-design: true
```

Чтобы добавить свои иконки, недостаточно просто добавить их как ассеты. Ваш собственный набор иконок должен быть создан как шрифт, и уже файл шрифта нужно будет добавить в качестве ассета. Для преобразования иконок в шрифт можно воспользоваться сайтом [fluttericon.com](https://www.fluttericon.com/). Также распространён подход с использованием пакета `flutter_svg`, который позволяет загружать `.svg` иконки в виде ассетов.

### Image

[`Image`](https://api.flutter.dev/flutter/widgets/Image-class.html) используется для отображения изображений в форматах JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP и WBMP. В основном конструкторе есть обязательный параметр `image`, имеющий тип [`ImageProvider`](https://api.flutter.dev/flutter/painting/ImageProvider-class.html) — он должен предоставить непосредственно изображение, изолировав виджет от источника.

Для удобства работы у `Image` есть несколько именованных конструкторов, которые создают нужный `ImageProvider`. Чаще всего используются конструкторы `Image.asset` (для изображений из ассетов) и `Image.network` (для изображений из интернета).

```dart
import 'package:flutter/material.dart';

class ImageExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        const Image(
          image: NetworkImage('https://placekitten.com/640/360'),
          height: 200,
          fit: BoxFit.contain,
        ),
        const SizedBox(height: 20),
        Image.network(
          'bad url',
          loadingBuilder: (context, child, loadingProgress) {
            if (loadingProgress == null) {
              return child;
            }
            return const Text('Loading');
          },
          errorBuilder: (context, _, __) => const Text('Error'),
        ),
      ],
    );
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: ImageExample(),
      ),
    );
  }
}
```

`Image` позволяет задавать различные параметры, в том числе определить отображение виджета при загрузке изображений или в случае ошибки. Стоит упомянуть параметр `fit` типа `BoxFit`: он позволяет настроить, как изображение будет размещаться внутри виджета — будет ли оно растянуто или сохранит пропорции и т.д. Различные значения `BoxFit` с примерами разобраны в [официальной документации](https://api.flutter.dev/flutter/painting/BoxFit.html).

По умолчанию `Image.network` не умеет кэшировать изображения, что обычно необходимо в приложениях. Например, без кэширования изображения могут повторно загружаться при пролистывании списков, когда элемент уходит с экрана и возвращается. Чтобы решить эту проблему, можно использовать различные пакеты. Например, разработчики Flutter [рекомендуют](https://docs.flutter.dev/cookbook/images/cached-images) использовать `cached_network_image`.

### GestureDetector, InkWell

Тяжело представить приложение, с которым пользователь не может взаимодействовать, например, нажатием на какие-то элементы. Самый простой виджет для обработки жестов — [`GestureDetector`](https://api.flutter.dev/flutter/widgets/GestureDetector-class.html). Он содержит множество методов, позволяя обрабатывать жесты от простого нажатия до сложных свайпов.

```dart
import 'package:flutter/material.dart';

class GestureExample extends StatefulWidget {
  @override
  State<GestureExample> createState() => _GestureExampleState();
}

class _GestureExampleState extends State<GestureExample> {
  String? _lastEvent;
  
  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () {
        setState(() => _lastEvent = 'onTap');
      },
      onDoubleTap: () {
        setState(() => _lastEvent = 'onDoubleTap');
      },
      onLongPress: () {
        setState(() => _lastEvent = 'onLongPress');
      },
      child: Container(
        width: 200,
        height: 200,
        color: Colors.blue,
        child: Center(
          child: Text(_lastEvent == null ? 'Tap me' : 'Last Event: $_lastEvent'),
        )
      ),
    );
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: GestureExample(),
      ),
    );
  }
}
```

Если вы делаете кликабельным какой-то текст, иконку или другой элемент интерфейса, нужно помнить об удобстве пользователей и делать кликабельную область такого размера, чтобы на элемент было удобно нажимать.

Если вам кажется, что кликабельная область слишком мала, первой идеей будет увеличить размер дочернего элемента у `GestureDetector`, например, обернуть его в `Padding`:

```dart
import 'package:flutter/material.dart';

class GestureDetectorExample extends StatefulWidget {
  const GestureDetectorExample({super.key});

  @override
  State<GestureDetectorExample> createState() => _GestureDetectorExampleState();
}

class _GestureDetectorExampleState extends State<GestureDetectorExample> {
  bool _lightIsOn = false;

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: <Widget>[
        Padding(
          padding: const EdgeInsets.all(8.0),
          child: Icon(
            Icons.lightbulb_outline,
            color: _lightIsOn ? Colors.yellow.shade600 : Colors.black,
            size: 60,
          ),
        ),
        GestureDetector(
          onTap: () {
            setState(() {
              _lightIsOn = !_lightIsOn;
            });
          },
          child: Padding(
            padding: const EdgeInsets.all(24),
            child: Text(_lightIsOn ? 'Выключить свет' : 'Включить свет'),
          ),
        ),
      ],
    );
  }

  @override
  void dispose() {
    super.dispose();
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      home: Scaffold(
        body: GestureDetectorExample(),
      ),
    );
  }
}
```

Но если вы также попробуете запустить этот пример на устройстве, то увидите, что ничего не изменилось, область нажатия осталась прежней. Дело в том, что `GestureDetector` по умолчанию игнорирует прозрачные области элементов. Чтобы изменить это поведение, необходимо воспользоваться параметром `behavior`. В нашем случае подойдёт значение `HitTestBehavior.opaque`:

```dart
import 'package:flutter/material.dart';

class GestureDetectorExample extends StatefulWidget {
  const GestureDetectorExample({super.key});

  @override
  State<GestureDetectorExample> createState() => _GestureDetectorExampleState();
}

class _GestureDetectorExampleState extends State<GestureDetectorExample> {
  bool _lightIsOn = false;

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: <Widget>[
        Padding(
          padding: const EdgeInsets.all(8.0),
          child: Icon(
            Icons.lightbulb_outline,
            color: _lightIsOn ? Colors.yellow.shade600 : Colors.black,
            size: 60,
          ),
        ),
        GestureDetector(
          behavior: HitTestBehavior.opaque,
          onTap: () {
            setState(() {
              _lightIsOn = !_lightIsOn;
            });
          },
          child: Padding(
            padding: const EdgeInsets.all(24),
            child: Text(_lightIsOn ? 'Выключить свет' : 'Включить свет'),
          ),
        ),
      ],
    );
  }

  @override
  void dispose() {
    super.dispose();
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      home: Scaffold(
        body: GestureDetectorExample(),
      ),
    );
  }
}
```

[`InkWell`](https://api.flutter.dev/flutter/material/InkWell-class.html) представляет собой аналог `GestureDetector`, но помимо обработки жестов он предоставляет стандартную анимацию в стиле Material Design. Такая анимация называется “Ripple”. Чтобы анимация была видна, `InkWell` должен быть обернут в виджет `Material`.

```dart
import 'package:flutter/material.dart';

class GestureDetectorExample extends StatefulWidget {
  const GestureDetectorExample({super.key});

  @override
  State<GestureDetectorExample> createState() => _GestureDetectorExampleState();
}

class _GestureDetectorExampleState extends State<GestureDetectorExample> {
  bool _lightIsOn = false;

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: <Widget>[
        Padding(
          padding: const EdgeInsets.all(8.0),
          child: Icon(
            Icons.lightbulb_outline,
            color: _lightIsOn ? Colors.yellow.shade600 : Colors.black,
            size: 60,
          ),
        ),
        Material(
          child: InkWell(
            onTap: () {
              setState(() {
                _lightIsOn = !_lightIsOn;
              });
            },
            child: Padding(
              padding: const EdgeInsets.all(24),
              child: Text(_lightIsOn ? 'Выключить свет' : 'Включить свет'),
            ),
          ),
        ),
      ],
    );
  }

  @override
  void dispose() {
    super.dispose();
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      home: Scaffold(
        body: GestureDetectorExample(),
      ),
    );
  }
}
```

### TextField, Button

Хотя `GestureDetector` даёт хорошие низкоуровневые возможности по обработке различных жестов, во Flutter существует множество стандартных кнопок, как в Material-, так и в Cupertino-стилях. То же самое относится и к текстовым полям.

```dart
import 'package:flutter/material.dart';

class FieldAndButtonExample extends StatefulWidget {
  const FieldAndButtonExample({super.key});

  @override
  State<FieldAndButtonExample> createState() => _FieldAndButtonExampleState();
}

class _FieldAndButtonExampleState extends State<FieldAndButtonExample> {
  TextEditingController? _loginController;
  TextEditingController? _passwordController;

  @override
  void initState() {
    super.initState();
    _loginController = TextEditingController();
    _passwordController = TextEditingController();
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      alignment: Alignment.center,
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: <Widget>[
          SizedBox(
            width: 250,
            child: TextField(
              controller: _loginController,
              decoration: const InputDecoration(
                labelText: 'Login',
              ),
            ),
          ),
          const SizedBox(height: 32),
          SizedBox(
            width: 250,
            child: TextField(
              controller: _passwordController,
              obscureText: true,
              decoration: const InputDecoration(
                border: OutlineInputBorder(),
                labelText: 'Password',
              ),
            ),
          ),
          const SizedBox(height: 32),
          ElevatedButton(
            onPressed: () {
              print(_loginController?.text);
              print(_passwordController?.text);
            },
            child: const Text('Sign in'),
          ),
          const SizedBox(height: 32),
          TextButton(
            onPressed: () {},
            child: const Text('Recover password'),
          ),
        ],
      ),
    );
  }

  @override
  void dispose() {
    _loginController?.dispose();
    _passwordController?.dispose();
    super.dispose();
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      home: Scaffold(
        body: FieldAndButtonExample(),
      ),
    );
  }
}
```

### SnackBar

[`SnackBar`](https://api.flutter.dev/flutter/material/SnackBar-class.html) — способ показать пользователю неблокирующие сообщения поверх остального интерфейса. Чтобы стало понятнее, давайте посмотрим пример:

```dart
import 'package:flutter/material.dart';

class SnackbarExample extends StatefulWidget {
  const SnackbarExample({super.key});

  @override
  State<SnackbarExample> createState() => _SnackbarExampleState();
}

class _SnackbarExampleState extends State<SnackbarExample> {
  @override
  Widget build(BuildContext context) {
    return Container(
      alignment: Alignment.center,
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: <Widget>[
          ElevatedButton(
            onPressed: () {
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Row(
                    children: [
                      Icon(Icons.bolt),
                      Text('Hello from SnackBar!'),
                    ],
                  ),
                  backgroundColor: Colors.indigo,
                  duration: Duration(seconds: 5),
                  showCloseIcon: true,
                ),
              );
            },
            child: const Text('Show SnackBar!'),
          ),
        ],
      ),
    );
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      home: Scaffold(
        body: SnackbarExample(),
      ),
    );
  }
}
```

Взаимодействие со снекбаром происходит при помощи `ScaffoldMessenger.of(context)`, это как раз ещё одна из обязанностей `Scaffold`. При помощи параметров снекбара можно изменять различные параметры отображения и поведения.

## Расположение

### Column, Row, Stack

Виджеты [`Column`](https://api.flutter.dev/flutter/widgets/Column-class.html) и [`Row`](https://api.flutter.dev/flutter/widgets/Row-class.html) служат для расположения дочерних виджетов друг за другом вертикально или горизонтально соответственно.

```dart
import 'package:flutter/material.dart';

class ColumnRowExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        const Text('Привет!'),
        Image.network(
          'https://placekitten.com/640/360',
          height: 200,
          fit: BoxFit.cover,
        ),
        const Row(children: [
          Text('Текст внутри Row'),
          Icon(Icons.favorite),
          Text('Текст внутри Row'),
        ]),
        const Text('Текст после Row'),
      ],
    );
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: ColumnRowExample(),
      ),
    );
  }
}
```

`Column` и `Row` работают по одинаковой логике, разница лишь в том, какая используется ось, так что параметры мы рассмотрим на примере `Column`.

- **`mainAxisAlignment`** — регулирует то, как дочерние элементы будут расположены по основной (в случае `Column` — вертикальной) оси. Например, параметр `MainAxisAlignment.start` расположит элементы в начале колонки, а `MainAxisAlignment.spaceBetween` распределит свободное пространство между элементами.
- **`mainAxisSize`** — задаёт, сколько места виджет займёт по основной оси. `MainAxisSize.min` означает, что колонка займет минимально возможное расстояние по вертикальной оси, а `MainAxisSize.max` заставит колонку занять всё доступное место.
- **`crossAxisAlignment`** — позволяет задать, сколько места по второстепенной (в случае `Column` — горизонтальной) оси будут занимать дочерние виджеты. Например, с помощью `CrossAxisAlignment.end` можно прижать виджеты к правой части колонки, а с помощью `CrossAxisAlignment.stretch` заставить их растянуться по всей ширине колонки.

Можно сказать, что на `Column` и `Row` строится большая часть вёрстки, так что их комбинация с разными параметрами позволяет создавать действительно сложный UI. На примере ниже вы можете попробовать применить разные значения свойств и увидеть, как меняется отображение элементов.

```dart
import 'package:flutter/material.dart';

class ColumnRowExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Container(
            width: 100,
            height: 100,
            color: Colors.red,
          ),
          const Row(
            mainAxisAlignment: MainAxisAlignment.start,
            children: [
              Icon(Icons.bolt),
              Icon(Icons.favorite),
              Icon(Icons.audiotrack),
            ],
          ),
          Container(
            width: 100,
            height: 100,
            color: Colors.yellow,
          ),
          const Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
              Icon(Icons.bolt),
              Icon(Icons.favorite),
              Icon(Icons.audiotrack),
            ],
          ),
          Container(
            width: 100,
            height: 100,
            color: Colors.green,
          ),
        ],
      ),
    );
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: ColumnRowExample(),
      ),
    );
  }
}
```

[`Stack`](https://api.flutter.dev/flutter/widgets/Stack-class.html) тоже помогает располагать виджеты, но не относительно друг друга, а относительно самого стека. При помощи него может быть удобно реализовывать наложение виджетов:

```dart
import 'package:flutter/material.dart';

class StackExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Center(
      child: Stack(
        clipBehavior: Clip.none,
        children: [
          Container(
            width: 100,
            height: 100,
            color: Colors.blue,
          ),
          Positioned(
            top: -10,
            right: -10,
            child: Container(
              width: 24,
              height: 24,
              decoration: const BoxDecoration(
                shape: BoxShape.circle,
                color: Colors.red,
              ),
              child: const Center(child: Text('+1')),
            ),
          )
        ]
      ),
    );
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: StackExample(),
      ),
    );
  }
}
```

### SingleChildScrollView

[`SingleChildScrollView`](https://api.flutter.dev/flutter/widgets/SingleChildScrollView-class.html) представляет собой простой скроллирующийся контейнер. В него можно положить дочерний виджет, размеры которого превышают доступную область для отрисовки, и тогда у пользователя будет возможность пролистать содержимое.

```dart
import 'package:flutter/material.dart';

class SingleChildScrollViewExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: List.generate(200, (index) => Text('Item $index')),
      ),
    );
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: SingleChildScrollViewExample(),
      ),
    );
  }
}
```

У виджета можно задать следующие параметры:

- **`scrollDirection`** (`Axis.vertical`/`Axis.horizontal`) — направление прокрутки: горизонтальное или вертикальное.
- **`reverse`** — прямое или обратное направление прокрутки. Обратное направление может быть полезно, например, для реализации списка сообщений, когда мы хотим отобразить сразу конец списка.
- **`padding`** — отступы внутри списка. В случае задания этого параметра отступы будут находиться внутри прокручиваемой области, то есть поведение будет отличаться от ситуации, когда мы бы обернули `SingleChildScrollView` в `Padding`.
- **`physics`** — позволяет задать различную физику скролла, например, как на iOS, либо выключить скролл вообще.
- **`clipBehavior`** — как будет обрезаться содержимое, выходящее за границы виджета.

### ListView

[`ListView`](https://api.flutter.dev/flutter/widgets/ListView-class.html) — это виджет для отображения прокручиваемых списков, и с первого взгляда он похож на `SingleChildScrollView`, но давайте рассмотрим примеры использования:

```dart
import 'package:flutter/material.dart';

class ListViewExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      padding: const EdgeInsets.symmetric(vertical: 16),
      itemCount: 200,
      itemBuilder: (context, index) => Text('Item $index'),
    );
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: ListViewExample(),
      ),
    );
  }
}
```

Однако, помимо другого API (возможности сразу передавать список элементов или использовать `builder`), `ListView` намного лучше оптимизирован для работы с большим количеством элементов, чем `SingleChildScrollView`.

Он отрисовывает только ту часть элементов, которая видна на экране, и несколько элементов в обе стороны скролла (чтобы не было задержек при скролле). В примере ниже используется `ListView.builder`, в котором логируются вызовы `itemBuilder`.

```dart
import 'package:flutter/material.dart';

class ListViewExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      padding: const EdgeInsets.symmetric(vertical: 16),
      itemCount: 1000,
      itemBuilder: (context, index) { 
        print('build item $index');
        return Text('Item $index');
      }
    );
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: ListViewExample(),
      ),
    );
  }
}
```

Вы можете попробовать пролистать список и увидеть, что лог показывается только для нужных в данный момент элементов. Похожий эксперимент с `SingleChildScrollView` даст совершенно другой результат: мы увидим лог из `builder` сразу всех элементов:

```dart
import 'package:flutter/material.dart';

class SingleChildScrollViewExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: List.generate(1000, (index) {
          print('build item $index');
          return Text('Item $index');
        }),
      ),
    );
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: SingleChildScrollViewExample(),
      ),
    );
  }
}
```

Помимо оптимизации, у `ListView` есть удобный конструктор `ListView.separated`, с помощью которого можно автоматически добавлять отступы между элементами списка.

```dart
import 'package:flutter/material.dart';

class ListViewSeparatedExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ListView.separated(
      padding: const EdgeInsets.symmetric(vertical: 16),
      itemCount: 200,
      itemBuilder: (context, index) => Container(
        color: Colors.green,
        child: Text('Item $index'),
      ),
      separatorBuilder: (context, index) => const SizedBox(height: 16),
    );
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: ListViewSeparatedExample(),
      ),
    );
  }
}
```

Наконец, рассмотрим параметр `shrinkWrap` — он заставляет `ListView` рассчитать свой размер по основной оси. В случае `shrinkWrap: false` (по умолчанию) `ListView` занимает всё доступное пространство по основной оси. В случае же `shrinkWrap: true` он занимает ровно столько места, сколько занимает содержимое.

Использовать этот параметр нужно с осторожностью и только если есть необходимость. Например, если вам нужно положить `ListView` в другой скроллирующийся контейнер. Причина в том, что для расчёта высоты придётся произвести лэйаут сразу всех элементов списка, и оптимизации `ListView` сойдут на нет.

### SizedBox

[`SizedBox`](https://api.flutter.dev/flutter/widgets/SizedBox-class.html) — простой виджет, позволяющий ограничить размеры дочернего виджета.

```dart
import 'package:flutter/material.dart';

class SizedBoxExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return const Column(
      children: [
        SizedBox(
          height: 100,
          child: ColoredBox(
            color: Colors.green,
            child: Text('Текст в SizedBox высотой 100'),
          ),
        ),
        SizedBox(
          height: 200,
          child: ColoredBox(
            color: Colors.red,
            child: Text('Текст в SizedBox высотой 200'),
          ),
        ),
      ],
    );
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: SizedBoxExample(),
      ),
    );
  }
}
```

Часто можно встретить использование `SizedBox` в качестве разделителя в списках (так как ему необязательно передавать `child`). Также встречается использование конструкции `const SizedBox.shrink()` в качестве «пустого виджета» (например, когда метод должен вернуть виджет, но мы не хотим что-либо отображать).

### Padding

[`Padding`](https://api.flutter.dev/flutter/widgets/Padding-class.html) — простой виджет, который помогает добавить отступы вокруг его дочернего элемента. Сами отступы задаются параметром типа [`EdgeInsets`](https://api.flutter.dev/flutter/painting/EdgeInsets-class.html), у которого есть множество именованных конструкторов:

```dart
import 'package:flutter/material.dart';

class PaddingExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return const Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: EdgeInsets.all(16),
          child: ColoredBox(
            color: Colors.green,
            child: Text('Текст с отступами'),
          ),
        ),
        Padding(
          padding: EdgeInsets.symmetric(vertical: 24),
          child: Icon(
            Icons.bolt,
          ),
        ),
        Padding(
          padding: EdgeInsets.only(left: 16),
          child: Icon(
            Icons.favorite,
          ),
        ),
        Icon(
          Icons.alarm,
        ),
      ],
    );
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: PaddingExample(),
      ),
    );
  }
}
```

### SafeArea

[`SafeArea`](https://api.flutter.dev/flutter/widgets/SafeArea-class.html) отвечает за добавление отступов, равных размерам системных элементов интерфейса, таких как статус-бар или нижняя навигационная панель. В DartPad `SafeArea` не даст эффекта, потому что в нём нет системных элементов. Чтобы обойти это, мы сэмулируем отступ, добавив в дерево виджет `MediaQuery`:

```dart
import 'package:flutter/material.dart';

class SafeAreaExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Container(
        color: Colors.cyan,
      ),
    );
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: MediaQuery(
        data: const MediaQueryData(
          padding: EdgeInsets.only(
            top: 48,
            bottom: 24,
          ),
        ),
        child: Scaffold(
          body: SafeAreaExample(),
        ),
      ),
    );
  }
}
```

`SafeArea` использует `MediaQuery.of(context)` для получения информации о необходимых размерах отступов. Виджет появляется в дереве благодаря `WidgetsApp`.

Если провести эксперимент и обернуть виджет `SafeArea` в самого себя, мы не получим двойных отступов — ничего не изменится. Так происходит, потому что `SafeArea` переопределяет `MediaQuery`, и виджеты ниже по дереву используют уже новые данные.

По умолчанию `SafeArea` добавит отступы со всех сторон, но бывают ситуации, когда отступ нужен только с определённых сторон. `SafeArea` позволяет настроить это при помощи параметров `top`, `bottom`, `left`, `right`. Например, если вы хотите отрисовать заголовок, вам не нужно добавлять к нему отступ снизу. Или если вы хотите показать кнопку внизу страницы, вам будет мешать верхний отступ.

```dart
import 'package:flutter/material.dart';

class SafeAreaExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Expanded(
          child: SafeArea(
            bottom: false,
            child: Container(
              color: Colors.indigo,
              child: const Center(
                child: Text('Only top SafeArea'),
              ),
            ),
          ),
        ),
        Expanded(
          child: SafeArea(
            top: false,
            child: Container(
              color: Colors.purple,
              child: const Center(
                child: Text('Only bottom SafeArea'),
              ),
            ),
          ),
        ),
      ],
    );
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: MediaQuery(
        data: const MediaQueryData(
          padding: EdgeInsets.only(
            top: 48,
            bottom: 24,
          ),
        ),
        child: Scaffold(
          body: SafeAreaExample(),
        ),
      ),
    );
  }
}
```

Также, если необходимо, вы сами можете воспользоваться `MediaQuery.of(context).padding`, чтобы получить отступы в виде `EdgeInsets` и передать их в какой-либо виджет.

## Декорация

### Container

[`Container`](https://api.flutter.dev/flutter/widgets/Container-class.html) позволяет декорировать ваш контент, например, добавить фон или тень.

```dart
import 'package:flutter/material.dart';

class ContainerExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Container(
      height: 200,
      padding: const EdgeInsets.all(16),
      margin: const EdgeInsets.all(24),
      alignment: Alignment.center,
      transform: Matrix4.rotationZ(0.1),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(40),
        border: Border.all(
          width: 8,
          color: Colors.purple,
        ),
        boxShadow: const [
          BoxShadow(
            blurRadius: 16,
            spreadRadius: 16,
            color: Colors.black54,
          ),
        ],
        gradient: const LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment(0.8, 1),
          colors: <Color>[
            Color(0xff1f005c),
            Color(0xff5b0060),
            Color(0xff870160),
            Color(0xffac255e),
            Color(0xffca485c),
            Color(0xffe16b5c),
            Color(0xfff39060),
            Color(0xffffb56b),
          ],
          tileMode: TileMode.mirror,
        ),
      ),
      child: Text(
        'Hello, I am Container!',
        style: Theme.of(context)
            .textTheme
            .headlineSmall!
            .copyWith(color: Colors.white),
      ),
    );
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: MediaQuery(
        data: const MediaQueryData(
          padding: EdgeInsets.only(
            top: 48,
            bottom: 24,
          ),
        ),
        child: Scaffold(
          body: ContainerExample(),
        ),
      ),
    );
  }
}
```

Как вы можете видеть, параметры контейнера говорят сами за себя. Под капотом `Container` представляет собой композицию специальных виджетов. Например, для отступов он использует виджет `Padding`, для декорирования — [`DecoratedBox`](https://api.flutter.dev/flutter/widgets/DecoratedBox-class.html).

В [параграфе «Widgets: layout»](https://academy.yandex.ru/handbook/flutter/article/widgets-layout) вы подробно узнаете о том, как происходит лэйаут контейнера.

## Заключение

Теперь, когда вы познакомились со стандартными виджетами, вы можете композировать их, чтобы получать более сложные компоненты. Не забывайте использовать [каталог виджетов](https://docs.flutter.dev/ui/widgets), так как библиотека Flutter обширна и позволяет многое делать «из коробки».

Также рекомендуем ознакомиться с серией роликов [Widget Of The Week](https://www.youtube.com/playlist?list=PLjxrf2q8roU23XGwz3Km7sQZFTdB996iG), где команда Flutter в формате минутных роликов рассказывает о полезных виджетах.