---
title: 3. Типы виджетов
description: description
---
Как уже было упомянуто, всего существует три базовых типа виджетов: `Stateless`, `Stateful`, `Inherited`.

## Stateless

`StatelessWidget` — виджет, не имеющий состояния. Он позволяет декомпозировать UI.

Чтобы создать собственный `StatelessWidget`, можно использовать сниппет `stless` (работает в IDE с установленным плагином Flutter, который создаст следующий класс:

```dart
class SomeWidget extends StatelessWidget { 
	const SomeWidget({Key? key}) : super(key: key); 
	
	@override 
	Widget build(BuildContext context) { 
		return const Placeholder(); 
	} 
}
```

Как видите, это просто класс, который наследуется от абстрактного класса `StatelessWidget` и реализует метод `build`. Из build-метода мы должны вернуть объект типа `Widget`.

Необязательный параметр конструктора `key` — уникальный идентификатор для `Widget`. Подробнее ключи будут рассмотрены в следующих параграфах. Сейчас мы примем за правило, что возможность передать ключ должна быть у любого виджета.

У build-метода есть аргумент `BuildContext context`. BuildContext — это интерфейс, который предоставляет виджету методы, чтобы взаимодействовать с деревом элементов. К контексту и элементам мы скоро вернёмся.

Теперь давайте переделаем наш `Hello, World` с использованием `StatelessWidget`. Для этого необходимо создать наследник класса `StatelessWidget` и перенести виджет `Column` из функции `main` в метод `build`.

```dart
void main() {
  runApp(
    const HelloWidget(
      text: 'Hello, I am StatelessWidget!',
    ),
  );
}

class HelloWidget extends StatelessWidget {
  final IconData icon;
  final String text;

  const HelloWidget({
    required this.text,
    this.icon = Icons.bolt,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Icon(
          icon,
          size: 32,
          textDirection: TextDirection.ltr,
        ),
        Text(
          text,
          textDirection: TextDirection.ltr,
        ),
      ],
    );
  }
}
```

Обратите внимание, что мы использовали final-поля в `StatelessWidget`, чтобы передать параметры извне. В нашей задаче это было вовсе не обязательно, но такой подход часто используется, когда мы хотим управлять параметрами или поведением виджета.
## Жизненный цикл

`StatelessWidget` во Flutter представляет собой виджет, который не изменяется после создания. Его жизненный цикл довольно простой, так как он не содержит состояния и не обновляется после первоначальной сборки. Вот основные этапы жизненного цикла `StatelessWidget`:

1. **Создание (Constructor)**: 
   Конструктор `StatelessWidget` вызывается, когда виджет создается. На этом этапе инициализируются все переменные, которые передаются в виджет. Виджет получает все необходимые данные и зависимости через конструктор.

2. **Сборка (build)**:
   Метод `build` вызывается для отрисовки `StatelessWidget`. В этом методе виджет определяет, как он должен отображаться на экране, возвращая дерево других виджетов. Это единственный метод жизненного цикла, который должен быть реализован для `StatelessWidget`. Когда `build` вызывается, Flutter генерирует дерево виджетов и отображает его на экране.

3. **Удаление (Dispose)**:
   Хотя `StatelessWidget` не имеет состояния, его также может быть нужно удалить, если родительский виджет меняется или если само дерево виджетов перестраивается. Однако `StatelessWidget` не имеет явного метода `dispose`, поскольку он не содержит ресурсов, которые нуждаются в освобождении или очистке.

### Основные моменты жизненного цикла:

- `StatelessWidget` создается только один раз и больше не обновляется, если его свойства не изменяются.
- Если Flutter обнаруживает необходимость обновления, `StatelessWidget` будет полностью пересоздан, а не обновлен как `StatefulWidget`.
- Поскольку `StatelessWidget` не хранит состояния, его проще использовать и тестировать, особенно в ситуациях, где виджет зависит исключительно от входных данных.

Таким образом, жизненный цикл `StatelessWidget` в основном сводится к выполнению конструктора и метода `build`.

# Stateful

`StatelessWidget` — хороший инструмент для декомпозиции UI. Однако приложения содержат большое количество изменяющихся данных, которые образуют состояние. Давайте рассмотрим виджет, позволяющий изменять состояние приложения.

`StatefulWidget` — виджет, имеющий изменяемое состояние.

Создать `StatefulWidget` можно, используя сниппет `stful`. Либо, если у вас уже есть `StatelessWidget` и вы хотите превратить его в Stateful, это можно быстро сделать при помощи хоткея:

1. установите курсор на имени класса вашего `StatelessWidget`;
2. нажмите сочетание клавиш:
    1. DartPad/AndroidStudio/IDEA: `Alt + Enter` на Windows, `Option + Enter` на macOS;
    2. VS Code: `Ctrl + .` на Windows и `Cmd + .` на macOS;
3. выберите в появившейся подсказке `Convert to StatefulWidget`.

Давайте рассмотрим пример:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(
    const MaterialApp(
      home: Bulb(),
    ),
  );
}

class Bulb extends StatefulWidget {
  const Bulb({
    super.key,
  });

  @override
  State<Bulb> createState() => _BulbState();
}

class _BulbState extends State<Bulb> {
  bool _isLightOn = false;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: _isLightOn ? Colors.white : Colors.black,
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.lightbulb,
              size: 32,
              color: _isLightOn ? Colors.yellow : Colors.grey,
            ),
            const SizedBox(height: 32),
            ElevatedButton(
              child: Text(_isLightOn ? 'Выключить свет' : 'Включить свет'),
              onPressed: () {
                setState(() {
                  _isLightOn = !_isLightOn;
                });
              },
            ),
          ],
        ),
      ),
    );
  }
}

```

Разберём код состояния `_BulbState`. В зависимости от значения поля `_isLightOn` выбираем нужный цвет фона, цвет иконки и текст на кнопке. Изменяется состояние при помощи обработчика нажатия `onPressed`у виджета `ElevatedButton`. При нажатии на кнопку происходит следующее:

1. Вызываем метод `setState` для изменения состояния.
2. Меняем значение поля `_isLightOn` на противоположное.
3. В `_BulbState` вызывается build-метод. Возвращаем новые виджеты, используя новое значение `_isLightOn`. Фреймворк встраивает новые виджеты на экран, и на экране виден актуальный UI.

`setState` — метод, определённый у `State`, который уведомляет фреймворк о том, что `State` изменился и его нужно перерисовать.

Так, основная идея декларативного UI во Flutter заключается в том, что для изменения UI нужно создавать новые экземпляры виджетов, а не изменять имеющиеся.

![](../../_assets/png/Снимок%20экрана%202024-11-07%20в%2019.24.38.png)

## Иммутабельность виджетов

Во Flutter любой виджет обязан быть иммутабельным, то есть у него не должно быть изменяемых полей. Вокруг этого принципа во многом построена внутренняя работа фреймворка, в том числе это помогает оптимизировать построение UI. Нарушать данный принцип нельзя, иначе вы получите непредвиденное поведение. Именно поэтому `StatefulWidget` разделен на две части — сам виджет, содержащий только иммутабельные поля, и состояние, которое может изменяться.

## Жизненный цикл

`StatefulWidget` во Flutter представляет собой виджет, который может изменять свое состояние во время жизни приложения. Это позволяет динамически обновлять интерфейс пользователя в ответ на события, такие как взаимодействие пользователя, получение данных из сети и другие изменения. Жизненный цикл `StatefulWidget` более сложен по сравнению с `StatelessWidget` и включает несколько этапов и методов, которые можно переопределять для управления поведением виджета.

### Основные этапы жизненного цикла `StatefulWidget`:

1. **Создание виджета (`StatefulWidget`):**
   
   - Когда `StatefulWidget` добавляется в дерево виджетов, вызывается метод `createState()`, который создает экземпляр класса `State`. Этот класс содержит состояние виджета и методы жизненного цикла.

2. **Инициализация состояния (`initState`):**
   
   - Метод `initState()` вызывается один раз при завершении создания состояния. Здесь можно инициализировать переменные, подписаться на потоки данных или выполнить другие операции, которые должны произойти только один раз.
   - **Важно:** Не вызывайте `BuildContext` или методы, зависящие от дерева виджетов, внутри `initState()`. Для этого используйте `didChangeDependencies()`.

3. **Зависимости (`didChangeDependencies`):**
   
   - Этот метод вызывается сразу после `initState()` и каждый раз, когда изменяются зависимости виджета, например, когда изменяется `InheritedWidget`, от которого зависит текущий виджет.
   - Полезно для получения данных из контекста, таких как темы или локализация.

4. **Построение виджета (`build`):**
   
   - Метод `build(BuildContext context)` вызывается каждый раз, когда необходимо отрисовать виджет. Это может происходить после вызова `setState()`, изменения родительского виджета или других событий, требующих обновления интерфейса.
   - В этом методе вы описываете, как должно выглядеть ваше виджет-дерево.

5. **Обновление виджета (`didUpdateWidget`):**
   
   - Метод `didUpdateWidget(covariant OldWidget oldWidget)` вызывается, когда конфигурация `StatefulWidget` изменяется (например, когда родительский виджет перестраивается и передает новые параметры).
   - Здесь можно сравнить старые и новые свойства и обновить состояние при необходимости.

6. **Активизация (`activate`):**
   
   - Этот метод вызывается, когда состояние вставляется в дерево виджетов. Обычно используется редко, но может быть полезен в сложных сценариях.

7. **Деактивизация (`deactivate`):**
   
   - Вызывается перед удалением состояния из дерева виджетов. Можно использовать для освобождения ресурсов или отмены подписок, которые не требуют полного уничтожения состояния.

9. **Удаление состояния (`dispose`):**
   - Метод `dispose()` вызывается, когда состояние больше не нужно и будет удалено. Здесь следует освобождать ресурсы, отменять подписки, контроллеры анимаций и другие объекты, которые требуют очистки.
   - **Важно:** После вызова `dispose()` состояние больше не активно, и любые попытки обновления интерфейса вызовут ошибки.

### Пример последовательности вызовов методов:

1. **Создание:**
   - `StatefulWidget` создается.
   - Вызывается `createState()`.

2. **Инициализация:**
   - `initState()`
   - `didChangeDependencies()`
   - `build()`

3. **Обновление:**
   - При изменении состояния вызывается `setState()`, что приводит к вызову `build()`.
   - Если конфигурация виджета изменилась, вызывается `didUpdateWidget()`.

4. **Удаление:**
   - `deactivate()`
   - `dispose()`

### Пример кода:

```dart
class MyStatefulWidget extends StatefulWidget {
  final String title;

  MyStatefulWidget({Key? key, required this.title}) : super(key: key);

  @override
  _MyStatefulWidgetState createState() => _MyStatefulWidgetState();
}

class _MyStatefulWidgetState extends State<MyStatefulWidget> {
  @override
  void initState() {
    super.initState();
    // Инициализация состояния
    print('initState');
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    // Обработка изменений зависимостей
    print('didChangeDependencies');
  }

  @override
  void didUpdateWidget(covariant MyStatefulWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    // Обработка обновления виджета
    print('didUpdateWidget');
  }

  @override
  void deactivate() {
    super.deactivate();
    // Обработка деактивации
    print('deactivate');
  }

  @override
  void dispose() {
    // Очистка ресурсов
    print('dispose');
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    print('build');
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            setState(() {
              // Обновление состояния
            });
          },
          child: Text('Обновить'),
        ),
      ),
    );
  }
}
```

В этом примере при создании `MyStatefulWidget` последовательно вызываются методы `initState()`, `didChangeDependencies()` и `build()`. При нажатии на кнопку вызывается `setState()`, который приводит к вызову `build()` для обновления интерфейса. Если `MyStatefulWidget` будет удален из дерева виджетов, вызовутся методы `deactivate()` и `dispose()` для очистки ресурсов.

### Ключевые моменты:

- **`initState()`**: Используется для инициализации состояния. Вызывается один раз.
- **`didChangeDependencies()`**: Вызывается при изменении зависимостей виджета.
- **`build()`**: Описывает, как должен выглядеть интерфейс. Вызывается много раз.
- **`didUpdateWidget()`**: Обрабатывает изменения конфигурации виджета.
- **`deactivate()` и `dispose()`**: Используются для очистки ресурсов перед удалением виджета.

Понимание жизненного цикла `StatefulWidget` позволяет эффективно управлять состоянием и ресурсами, обеспечивая производительность и стабильность приложения во Flutter.

### 1.1.5. Inherited

В предыдущем примере мы смогли легко поменять тему всего приложения. Мы всего лишь изменили один параметр `themeMode` у виджета `MaterialApp`, и при этом поменялись цвета всех дочерних виджетов (цвет фона, текста, `Switch`), хотя больше нигде явно не передавали информацию о теме. Такое возможно благодаря `InheritedWidget`.

`InheritedWidget`— виджет, позволяющий эффективно передавать данные вниз по дереву.

Если бы не было `InheritedWidget`, то для передачи любых данных от родительского виджета к дочернему пришлось бы передавать всю информацию через конструктор. Иногда бывают данные, которые нужны по всему приложению, например информация о направлении текста (слева направо или справа налево), информация о теме (цвета, шрифты и так далее). Такие данные было бы проблемно передавать через конструктор, потому что пришлось бы добавлять их во все виджеты — от корневого до самого последнего в дереве.

Посмотрим на пример реализации `InheritedWidget`.

Виджет `InheritedNumber` унаследован от `InheritedWidget`. К реализации есть два требования:

1. Конструктор должен содержать параметр `child`, чтобы было возможно передать дочерний виджет.
2. Обязательна реализация метода `updateShouldNotify`. Этот метод позволяет определить, когда дочерние виджеты будут уведомлены при изменении `InheritedWidget`.

Когда какой-то `InheritedWidget` встроен в дерево, дочерние виджеты могут подписаться на него при помощи метода `dependOnInheritedWidgetOfExactType` у `BuildContext`, который приходит в качестве параметра build-метода. Он возвращает родительский `InheritedWidget` нужного типа. Чтобы упростить работу с `InheritedWidget`, принято добавлять статичные методы `of` и `maybeOf`.

InheritedWidget могут использоваться довольно часто, например для доступа к теме, локализации. При каждом обращении к `InheritedWidget` будет вызываться `context.dependOnInheritedWidgetOfExactType`. Так как деревья элементов в реальных приложениях могут быть огромными, разработчики Flutter позаботились об оптимизации. Доступ к `InheritedWidget` осуществляется за O(1), то есть сложность доступа не зависит от размера дерева элементов. Это достигается благодаря тому, что в каждом Element хранится `Map` со ссылками на `InheritedWidget`, где в качестве ключа используется тип `InheritedWidget`.

При использовании `InheritedWidget` важно понимать, с каким именно `BuildContext` вы работаете. Посмотрите на следующий код:

```dart
class SomeWidget extends StatelessWidget {
  @override
	Widget build(BuildContext context) {
	  return InheritedNumber(
	    number: 1,
	    child: Text(InheritedNumber.of(context).number.toString()),
	  )
	}
}
```

В этом примере мы не сможем получить `InheritedNumber` , потому что `dependOnInheritedWidgetOfExactType` возвращает `InheritedWidget`, находящийся выше по дереву, чем `context`. Мы использовали `context` от `SomeWidget`, а `InheritedNumber` определён по дереву ниже.

Исправить приведённый код можно двумя способами. Первый вариант — вынести `Text` в отдельный виджет, как было в примере из начала данного пункта. Второй вариант — использовать виджет `Builder`:

```dart
class SomeWidget extends StatelessWidget {
  @override
	Widget build(BuildContext context) {
	  return InheritedNumber(
	    number: 1,
	    child: Builder(
        builder: (context) => Text(
          InheritedNumber.of(context).number.toString(),
        ),
      ),
	  )
	}
}
```

Builder позволяет получить `BuildContext` именно из того места дерева, в которое он встроен.

При этом из `of` и `maybeOf` необязательно возвращать сам `InheritedWidget`. Вы можете захотеть абстрагировать данные от самого виджета или выполнить какую-то дополнительную логику. Такое часто встречается в самом фреймворке. Посмотрим на реализацию `Theme.of`:

```dart
static ThemeData of(BuildContext context) {
  final _InheritedTheme? inheritedTheme = context.dependOnInheritedWidgetOfExactType<_InheritedTheme>();
  final MaterialLocalizations? localizations = Localizations.of<MaterialLocalizations>(context, MaterialLocalizations);
  final ScriptCategory category = localizations?.scriptCategory ?? ScriptCategory.englishLike;
  final ThemeData theme = inheritedTheme?.theme.data ?? _kFallbackTheme;
  return ThemeData.localize(theme, theme.typography.geometryThemeFor(category));
}
```

`InheritedWidget` лежит в основе многих стандартных виджетов и подходов и используется в реализации многих библиотек для state management. Даже если не будете часто создавать свои `InheritedWidget`, вы будете часто ими пользоваться.

- `InheritedWidget` — виджет, позволяющий передать данные вниз по дереву виджетов.
- `context.dependOnInheritedWidgetOfExactType` возвращает `InheritedWidget` определённого типа, если тот существует выше по дереву виджетов, и делает это за константное время.

## Жизненный цикл

`InheritedWidget` во Flutter — это специальный виджет, предназначенный для эффективного распространения информации вниз по дереву виджетов. Он часто используется в системах управления состоянием для предоставления данных потомкам без необходимости передавать их через каждый уровень виджетов. Жизненный цикл `InheritedWidget` отличается от `StatelessWidget` и `StatefulWidget`, так как он фокусируется на обновлении и уведомлении зависимых виджетов при изменении данных.

### Основные этапы жизненного цикла `InheritedWidget`:

1. **Создание (`constructor`)**:
   - `InheritedWidget` создается с необходимыми данными, которые должны быть доступны потомкам. Эти данные передаются через конструктор виджета.
   
   ```dart
   class MyInheritedWidget extends InheritedWidget {
     final int data;

     MyInheritedWidget({
       Key? key,
       required this.data,
       required Widget child,
     }) : super(key: key, child: child);

     @override
     bool updateShouldNotify(MyInheritedWidget oldWidget) {
       return data != oldWidget.data;
     }
   }
   ```

2. **Сборка (`build`)**:
   - Метод `build` вызывается для построения дерева виджетов. В случае `InheritedWidget` он обычно оборачивает дочерние виджеты, предоставляя им доступ к данным.
   
3. **Обновление (`update`)**:
   - Когда родительский виджет перестраивается и передает новые данные в `InheritedWidget`, вызывается метод `updateShouldNotify`.
   - Если `updateShouldNotify` возвращает `true`, Flutter уведомляет все зависимые виджеты об изменении данных, и они могут перестроиться для отображения обновленной информации.

4. **Уведомление зависимых виджетов**:
   - Потомки, которые зависят от `InheritedWidget`, получают уведомление об изменении через метод `didChangeDependencies`.
   - Эти потомки могут вызвать `setState`, чтобы обновить свое состояние и отобразить новые данные.

5. **Удаление (`dispose`)**:
   - Хотя `InheritedWidget` сам по себе не имеет метода `dispose`, его ресурсы освобождаются, когда он удаляется из дерева виджетов вместе с его дочерними виджетами.

### Ключевые методы и концепции:

- **`updateShouldNotify`**:
  - Этот метод определяет, должны ли зависимые виджеты быть уведомлены об изменении данных. Обычно сравнивают старые и новые значения данных.
  
  ```dart
  @override
  bool updateShouldNotify(MyInheritedWidget oldWidget) {
    return data != oldWidget.data;
  }
  ```

- **Получение данных потомками**:
  - Потомки используют методы, такие как `of`, для получения доступа к данным из `InheritedWidget`.
  
  ```dart
  class MyInheritedWidget extends InheritedWidget {
    // ... предыдущий код ...

    static MyInheritedWidget? of(BuildContext context) {
      return context.dependOnInheritedWidgetOfExactType<MyInheritedWidget>();
    }
  }
  ```

- **`didChangeDependencies`**:
  - В виджетах-потомках, которые зависят от `InheritedWidget`, метод `didChangeDependencies` вызывается, когда `InheritedWidget` обновляется. Это позволяет потомкам реагировать на изменения данных.
  
  ```dart
  class MyWidget extends StatefulWidget {
    @override
    _MyWidgetState createState() => _MyWidgetState();
  }

  class _MyWidgetState extends State<MyWidget> {
    @override
    void didChangeDependencies() {
      super.didChangeDependencies();
      final inherited = MyInheritedWidget.of(context);
      // Обработка обновленных данных
    }

    @override
    Widget build(BuildContext context) {
      final inherited = MyInheritedWidget.of(context);
      return Text('Data: ${inherited?.data}');
    }
  }
  ```

### Пример использования `InheritedWidget`:

```dart
import 'package:flutter/material.dart';

void main() => runApp(MyApp());

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MyInheritedWidget(
      data: 42,
      child: MaterialApp(
        home: Scaffold(
          appBar: AppBar(title: Text('InheritedWidget Example')),
          body: Center(child: MyChildWidget()),
        ),
      ),
    );
  }
}

class MyInheritedWidget extends InheritedWidget {
  final int data;

  MyInheritedWidget({
    Key? key,
    required this.data,
    required Widget child,
  }) : super(key: key, child: child);

  @override
  bool updateShouldNotify(MyInheritedWidget oldWidget) {
    return data != oldWidget.data;
  }

  static MyInheritedWidget? of(BuildContext context) {
    return context.dependOnInheritedWidgetOfExactType<MyInheritedWidget>();
  }
}

class MyChildWidget extends StatefulWidget {
  @override
  _MyChildWidgetState createState() => _MyChildWidgetState();
}

class _MyChildWidgetState extends State<MyChildWidget> {
  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    final inherited = MyInheritedWidget.of(context);
    print('didChangeDependencies: data = ${inherited?.data}');
  }

  @override
  Widget build(BuildContext context) {
    final inherited = MyInheritedWidget.of(context);
    return Text('Inherited Data: ${inherited?.data}');
  }
}
```

В этом примере `MyInheritedWidget` предоставляет значение `data` своим потомкам. Виджет `MyChildWidget` зависит от `MyInheritedWidget` и реагирует на изменения данных, обновляя свой интерфейс и вызывая `didChangeDependencies`.

### Ключевые моменты:

- **Эффективность**: `InheritedWidget` оптимизирован для минимизации количества перестроек виджетов. Только виджеты, зависящие от него, будут перестраиваться при изменении данных.
- **Неизменяемость**: Как и `StatelessWidget`, `InheritedWidget` сам по себе неизменяем, но может обновляться родительским виджетом, предоставляя новые данные.
- **Распространение данных**: Идеален для передачи данных, которые требуются многим виджетам на разных уровнях дерева, например, темы, локализации или состояния приложения.
- **Совместимость**: Часто используется в сочетании с системами управления состоянием, такими как Provider, которые упрощают работу с `InheritedWidget`.

### Заключение

Понимание жизненного цикла `InheritedWidget` важно для эффективного управления данными и состоянием в приложениях Flutter. Использование `InheritedWidget` позволяет создавать гибкие и масштабируемые архитектуры, обеспечивая простой и эффективный способ передачи данных вниз по дереву виджетов.