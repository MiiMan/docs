---
title: 5.  Современные стейт-менеджеры
description: description
author: Геннадий Альхеев
tableOfContents: false
---
# Оглавление

- [Введение](#%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5)
- [Общие концепции управления состоянием](#%D0%9E%D0%B1%D1%89%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BD%D1%86%D0%B5%D0%BF%D1%86%D0%B8%D0%B8-%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC)
- [MobX: реактивный подход к управлению состоянием](#mobx-%D1%80%D0%B5%D0%B0%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B4%D1%85%D0%BE%D0%B4-%D0%BA-%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8E-%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC)
	- [Основные принципы MobX](#%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-mobx)
	- [Преимущества MobX](#%D0%9F%D1%80%D0%B5%D0%B8%D0%BC%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B0-mobx)
	- [Пример использования MobX](#%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-mobx)
		- [1. Установка зависимостей](#1-%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B5%D0%B9)
		- [2. Создание модели состояния](#2-%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8-%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F)
		- [3. Генерация кода](#3-%D0%93%D0%B5%D0%BD%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D0%BA%D0%BE%D0%B4%D0%B0)
		- [4. Создание UI с MobX](#4-%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-ui-%D1%81-mobx)
- [BLoC: управление состоянием через события и состояния](#bloc-%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D1%8F-%D0%B8-%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F)
	- [Основные принципы BLoC](#%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-bloc)
		- [Разница между Bloc и Cubit](#%D0%A0%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-bloc-%D0%B8-cubit)
	- [Преимущества BLoC](#%D0%9F%D1%80%D0%B5%D0%B8%D0%BC%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B0-bloc)
	- [Пример использования BLoC](#%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-bloc)
		- [1. Установка зависимостей](#1-%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B5%D0%B9)
		- [2. Создание Cubit](#2-%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-cubit)
		- [3. Создание UI с Cubit](#3-%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-ui-%D1%81-cubit)
- [Сходства между MobX и BLoC](#%D0%A1%D1%85%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-mobx-%D0%B8-bloc)
- [Современные оптимизации в стейт-менеджерах](#%D0%A1%D0%BE%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D0%BE%D0%BF%D1%82%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%B2-%D1%81%D1%82%D0%B5%D0%B9%D1%82-%D0%BC%D0%B5%D0%BD%D0%B5%D0%B4%D0%B6%D0%B5%D1%80%D0%B0%D1%85)
- [Заключение](#%D0%97%D0%B0%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5)
- [Часто задаваемые вопросы](#%D0%A7%D0%B0%D1%81%D1%82%D0%BE-%D0%B7%D0%B0%D0%B4%D0%B0%D0%B2%D0%B0%D0%B5%D0%BC%D1%8B%D0%B5-%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D1%8B)

# Введение

Управление состоянием — одна из самых важных и одновременно сложных задач при разработке приложений на Flutter. С ростом сложности приложений возникает необходимость выбора подходящего стейт-менеджера, который обеспечит удобство, масштабируемость и производительность. В этой статье мы рассмотрим два популярных подхода к управлению состоянием: **MobX** и **BLoC**, их основные концепции, преимущества и практические примеры использования. Также обсудим общие концепции, лежащие в основе современных стейт-менеджеров, и как они оптимизируют обновление UI.

# Общие концепции управления состоянием

Современные стейт-менеджеры во многом основываются на реактивных принципах, позволяя автоматически обновлять только те части пользовательского интерфейса, которые действительно изменились. Это достигается через механизм наблюдения за изменениями состояния и реагирования на них. Основные компоненты таких систем включают:

- **Наблюдаемые данные**: Переменные или объекты, за изменениями которых наблюдают другие части приложения.
- **Действия (Actions/Events)**: Операции или события, изменяющие состояние приложения.
- **Реакции (Reactions)**: Логика, реагирующая на изменения в наблюдаемых данных и обновляющая UI или выполняющая другие задачи.
- **Состояния (States)**: Отражение текущего состояния приложения, которое используется для построения UI.

Эти концепции позволяют создавать предсказуемые и легко поддерживаемые приложения, где изменения состояния приводят к необходимым обновлениям интерфейса без избыточных перерисовок.

# MobX: реактивный подход к управлению состоянием

## Основные принципы MobX

**MobX** — это библиотека для управления состоянием, основанная на реактивном программировании. Она позволяет создавать наблюдаемые объекты, автоматически отслеживать зависимости и обновлять UI при изменении данных.

Основные компоненты MobX:

- **Observables (Наблюдаемые)**: Переменные, за которыми MobX будет наблюдать.
- **Actions (Действия)**: Методы, изменяющие состояние наблюдаемых данных.
- **Reactions (Реакции)**: Автоматические реакции на изменения в наблюдаемых данных, обновляющие UI или выполняющие другие действия.
- **Computed Values (Вычисляемые значения)**: Значения, которые автоматически пересчитываются при изменении зависимостей.

## Преимущества MobX

- **Простота использования**: Интуитивно понятный синтаксис и минимальное количество шаблонного кода.
- **Высокая производительность**: Обновляются только те виджеты, которые зависят от изменённых данных.
- **Гибкость**: Позволяет легко разделять логику и UI, улучшая тестируемость и поддерживаемость кода.
- **Реактивность**: Автоматическое управление зависимостями между данными и UI.

## Пример использования MobX

Рассмотрим простой пример приложения для управления списком задач с использованием MobX.

### 1. Установка зависимостей

Добавьте необходимые пакеты в `pubspec.yaml`:

```yaml
dependencies:
  flutter:
    sdk: flutter
  mobx: any
  flutter_mobx: any

dev_dependencies:
  build_runner: any
  mobx_codegen: any
```

### 2. Создание модели состояния

Создадим класс `TaskStore`, который будет управлять списком задач.

```dart
// stores/task_store.dart
import 'package:mobx/mobx.dart';

part 'task_store.g.dart';

class TaskStore = _TaskStore with _$TaskStore;

abstract class _TaskStore with Store {
  @observable
  ObservableList<String> tasks = ObservableList<String>();

  @action
  void addTask(String task) {
    tasks.add(task);
  }

  @action
  void removeTask(int index) {
    tasks.removeAt(index);
  }
}
```

**Комментарий:** Здесь мы используем аннотации `@observable` и `@action` для обозначения наблюдаемых данных и действий, изменяющих эти данные.

### 3. Генерация кода

Выполните команду для генерации необходимого кода:

```bash
flutter packages pub run build_runner build
```

### 4. Создание UI с MobX

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:flutter_mobx/flutter_mobx.dart';
import 'stores/task_store.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  final TaskStore taskStore = TaskStore();

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'MobX ToDo List',
      home: Scaffold(
        appBar: AppBar(
          title: Text('MobX ToDo List'),
        ),
        body: Column(
          children: [
            Expanded(
              child: Observer(
                builder: (_) => ListView.builder(
                  itemCount: taskStore.tasks.length,
                  itemBuilder: (_, index) {
                    final task = taskStore.tasks[index];
                    return ListTile(
                      title: Text(task),
                      trailing: IconButton(
                        icon: Icon(Icons.delete),
                        onPressed: () => taskStore.removeTask(index),
                      ),
                    );
                  },
                ),
              ),
            ),
            Padding(
              padding: const EdgeInsets.all(8.0),
              child: AddTaskWidget(taskStore: taskStore),
            ),
          ],
        ),
      ),
    );
  }
}

class AddTaskWidget extends StatefulWidget {
  final TaskStore taskStore;

  const AddTaskWidget({Key? key, required this.taskStore}) : super(key: key);

  @override
  _AddTaskWidgetState createState() => _AddTaskWidgetState();
}

class _AddTaskWidgetState extends State<AddTaskWidget> {
  final TextEditingController _controller = TextEditingController();

  void _addTask() {
    final task = _controller.text;
    if (task.isNotEmpty) {
      widget.taskStore.addTask(task);
      _controller.clear();
    }
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        Expanded(
          child: TextField(
            controller: _controller,
            decoration: InputDecoration(
              hintText: 'Введите задачу',
            ),
          ),
        ),
        IconButton(
          icon: Icon(Icons.add),
          onPressed: _addTask,
        ),
      ],
    );
  }
}
```

**Пояснение:**

- **Observer**: Виджет, который автоматически перестраивается при изменении наблюдаемых данных в `TaskStore`.
- **AddTaskWidget**: Локальный виджет для добавления новых задач, передаёт действия через `TaskStore`.

**Пример:** При добавлении новой задачи, только список задач обновляется, остальные виджеты остаются неизменными, что повышает производительность приложения.

# BLoC: управление состоянием через события и состояния

## Основные принципы BLoC

**BLoC** (Business Logic Component) — архитектурный паттерн, который управляет состоянием приложения через потоки событий и состояний. Он разделяет бизнес-логику от UI, обеспечивая независимость и тестируемость кода.

Основные компоненты BLoC:

- **Events (События)**: Действия или намерения пользователя, которые отправляются в BLoC для обработки.
- **States (Состояния)**: Различные состояния, которые может принимать приложение, в зависимости от обработки событий.
- **Bloc/Cubit**: Компонент, который принимает события, обрабатывает их и выдает новые состояния.

### Разница между Bloc и Cubit

- **Bloc**: Использует шаблон "Событие-Состояние", где вы определяете события и состояния отдельно.
- **Cubit**: Упрощенная версия Bloc, использующая только состояния, без явного определения событий. Подходит для простых случаев.

## Преимущества BLoC

- **Четкое разделение**: Бизнес-логика полностью отделена от UI, что упрощает поддержку и тестирование.
- **Предсказуемость**: Используя события и состояния, вы точно знаете, как приложение реагирует на определенные действия.
- **Масштабируемость**: Легко расширять функциональность приложения, добавляя новые события и состояния.
- **Повторное использование**: BLoC-компоненты могут быть использованы в разных частях приложения или даже в разных проектах.

## Пример использования BLoC

Рассмотрим пример того же приложения для управления списком задач, но с использованием BLoC.

### 1. Установка зависимостей

Добавьте необходимые пакеты в `pubspec.yaml`:

```yaml
dependencies:
  flutter:
    sdk: flutter
  flutter_bloc: any
```

### 2. Создание Cubit

Для простоты использования мы будем использовать **Cubit**, который является упрощенной версией Bloc.

```dart
// cubit/task_cubit.dart
import 'package:bloc/bloc.dart';

class TaskCubit extends Cubit<List<String>> {
  TaskCubit() : super([]);

  void addTask(String task) {
    emit([...state, task]);
  }

  void removeTask(int index) {
    final updatedList = List<String>.from(state)..removeAt(index);
    emit(updatedList);
  }
}
```

**Комментарий:** В данном случае состояние — это список задач (`List<String>`), а методы `addTask` и `removeTask` изменяют состояние, вызывая `emit` с новым значением.

### 3. Создание UI с Cubit

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'cubit/task_cubit.dart';

void main() {
  runApp(
    BlocProvider(
      create: (_) => TaskCubit(),
      child: MyApp(),
    ),
  );
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final primaryColor = Colors.green;

    return MaterialApp(
      title: 'Cubit ToDo List',
      theme: ThemeData(primaryColor: primaryColor),
      home: TaskView(),
    );
  }
}

class TaskView extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final taskCubit = context.read<TaskCubit>();

    return Scaffold(
      appBar: AppBar(
        title: Text('Cubit ToDo List'),
      ),
      body: BlocBuilder<TaskCubit, List<String>>(
        builder: (context, tasks) {
          return ListView.builder(
            itemCount: tasks.length,
            itemBuilder: (_, index) {
              final task = tasks[index];
              return ListTile(
                title: Text(task),
                trailing: IconButton(
                  icon: Icon(Icons.delete),
                  onPressed: () => taskCubit.removeTask(index),
                ),
              );
            },
          );
        },
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => _showAddTaskDialog(context, taskCubit),
        child: Icon(Icons.add),
      ),
    );
  }

  void _showAddTaskDialog(BuildContext context, TaskCubit taskCubit) {
    final _controller = TextEditingController();

    showDialog(
      context: context,
      builder: (_) => AlertDialog(
        title: Text('Добавить задачу'),
        content: TextField(
          controller: _controller,
          decoration: InputDecoration(hintText: 'Название задачи'),
        ),
        actions: [
          TextButton(
            onPressed: () {
              final task = _controller.text;
              if (task.isNotEmpty) {
                taskCubit.addTask(task);
                Navigator.pop(context);
              }
            },
            child: Text('Добавить'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text('Отмена'),
          ),
        ],
      ),
    );
  }
}
```

**Пояснение:**

- **BlocProvider**: Предоставляет экземпляр `TaskCubit` всему дереву виджетов.
- **BlocBuilder**: Строит UI на основе текущего состояния `TaskCubit`.
- **TaskCubit**: Содержит бизнес-логику для управления списком задач.
- **События**: В данном случае методы `addTask` и `removeTask` выступают в роли действий (Intent), изменяющих состояние.

**Пример:** При добавлении новой задачи метод `addTask` вызывается, и новое состояние эмитируется, что автоматически обновляет UI благодаря `BlocBuilder`.

# Сходства между MobX и BLoC

Несмотря на различия в реализации, **MobX** и **BLoC** имеют схожие концепции:

- **Состояние (State)**: Оба подхода работают с состоянием приложения, которое используется для построения UI.
- **Действия/События (Actions/Intents)**: В обоих случаях есть методы или события, которые изменяют состояние.
- **Реакции (Reactions)**: UI обновляется в ответ на изменения состояния.
- **Разделение логики и UI**: Оба подхода способствуют разделению бизнес-логики и пользовательского интерфейса.

**Общее между ними**:

- В **MobX** мы используем наблюдаемые данные (`@observable`), действия (`@action`) и реакции (`Observer`).
- В **BLoC/Cubit** мы имеем состояние, которое меняется в ответ на действия (методы Cubit или события Bloc), и UI обновляется через `BlocBuilder`.

# Современные оптимизации в стейт-менеджерах

Современные стейт-менеджеры, такие как **MobX** и **BLoC**, включают оптимизации, позволяющие обновлять не весь UI, а только те его части, которые действительно изменились. Это достигается за счёт точного отслеживания зависимостей и реактивного обновления виджетов.

**Пример оптимизации:**

- В **MobX**, благодаря `Observer`, только те виджеты, которые зависят от изменённых наблюдаемых данных, будут перестроены.
- В **BLoC**, `BlocBuilder` перестраивает только тот виджет, который зависит от изменившегося состояния.

# Заключение

Управление состоянием — критически важный аспект разработки Flutter-приложений. **MobX** и **BLoC** представляют два различных, но мощных подхода к решению этой задачи, каждый из которых имеет свои преимущества и подходит для различных сценариев.

- **MobX** предлагает простой и интуитивно понятный реактивный подход, позволяя автоматически отслеживать изменения состояния и обновлять UI.
- **BLoC** предоставляет строгую архитектурную модель, основанную на событиях и состояниях, обеспечивая чёткое разделение бизнес-логики и UI.

Современные стейт-менеджеры оптимизируют процесс обновления UI, обеспечивая высокую производительность и удобство разработки. Выбор между MobX и BLoC зависит от предпочтений команды, требований проекта и личных предпочтений разработчика.

**Рекомендации:**

- Изучите оба подхода и выберите тот, который лучше всего подходит для вашего проекта.
- Используйте **Provider** для упрощения передачи зависимостей и управления состоянием.
- Следуйте принципам реактивного программирования для создания предсказуемых и легко поддерживаемых приложений.
- Не забывайте о важности тестируемости и разделения ответственности в архитектуре вашего приложения.

# Часто задаваемые вопросы

**1. В чём разница между MobX и BLoC?**

**MobX** использует реактивное программирование для автоматического отслеживания изменений состояния и обновления UI. Он подходит для проектов, где требуется высокая гибкость и простота использования.

**BLoC** основывается на паттерне "Событие-Состояние", где вы определяете события (Intent), которые вызывают изменения состояния, и новые состояния, на основе которых обновляется UI. Он идеален для проектов, где требуется строгая архитектура и чёткое разделение бизнес-логики и UI.

**2. Можно ли комбинировать MobX и BLoC в одном проекте?**

Хотя технически это возможно, рекомендуется придерживаться одного подхода к управлению состоянием для обеспечения согласованности и упрощения поддержки кода.

**3. Как выбрать между MobX и BLoC для моего проекта?**

Выбор зависит от сложности проекта, требований к архитектуре, предпочтений команды и личного опыта разработчиков. Если вам нужен простой и гибкий инструмент, рассмотрите MobX. Если требуется строгая архитектура с чётким разделением бизнес-логики и UI, лучше выбрать BLoC.

**4. Какие альтернативы существуют помимо MobX и BLoC?**

Существуют и другие стейт-менеджеры, такие как **Redux**, **Riverpod**, **GetX**, **Provider**, каждый из которых имеет свои особенности и преимущества. Выбор зависит от конкретных потребностей вашего проекта.

**5. Как обеспечить тестируемость при использовании MobX и BLoC?**

Оба подхода способствуют высокой тестируемости за счёт разделения логики и UI. В **MobX** вы можете тестировать изменения состояния отдельно, а в **BLoC** — тестировать обработку событий и генерацию состояний. Используйте модульные тесты для проверки бизнес-логики и интеграционные тесты для проверки взаимодействия компонентов.