---
title: Конспект
description: Публичное описание файла
---
# 1. Основы построения UI
### 1.1. Императивный стиль
### 1.2. Декларативный стиль
### 1.3. Состояние рынка
# 2. Устройство Flutter
## 2.1. Первое приложение
Flutter следует концепции "все – это виджет". На практике это означает то, что все компоненты экрана являются Widget. Сам экран состоит из дерева виджетов и также является виджетом.

Давайте взглянем на код ниже:

```dart
import 'package:flutter/material.dart';  
  
void main() {  
  runApp(const MyApp());  
}  
  
class MyApp extends StatelessWidget {  
  const MyApp({super.key});  
  
  @override  
  Widget build(BuildContext context) {  
    return MaterialApp(  
      title: 'Flutter Demo',  
      theme: ThemeData(  
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),  
        useMaterial3: true,  
      ),  
      home: const MyHomePage(title: 'Flutter Demo Home Page'),  
    );  
  }  
}  
  
class MyHomePage extends StatefulWidget {  
  const MyHomePage({super.key, required this.title});  
  final String title;  
  
  @override  
  State<MyHomePage> createState() => _MyHomePageState();  
}  
  
class _MyHomePageState extends State<MyHomePage> {  
  int _counter = 0;  
  
  void _incrementCounter() {  
    setState(() {  
      _counter++;  
    });  
  }  
  
  @override  
  Widget build(BuildContext context) {  
    return Scaffold(  
      appBar: AppBar(  
        backgroundColor: Theme.of(context).colorScheme.inversePrimary,  
        title: Text(widget.title),  
      ),  
      body: Center(  
        child: Column(  
          mainAxisAlignment: MainAxisAlignment.center,  
          children: <Widget>[  
            const Text(  
              'You have pushed the button this many times:',  
            ),  
            Text(  
              '$_counter',  
              style: Theme.of(context).textTheme.headlineMedium,  
            ),  
          ],  
        ),  
      ),  
      floatingActionButton: FloatingActionButton(  
        onPressed: _incrementCounter,  
        tooltip: 'Increment',  
        child: const Icon(Icons.add),  
      ),  
    );  
  }  
}
```

Это код из официального примера. Давайте поделим его на логические части:
1) Точка входа в программу,
2) Инициализация приложения,
3) Инициализация главного экрана.

Давайте рассмотрим каждый из элементов подробнее.

### Точка входа

```dart
void main() {  
  runApp(const MyApp());  
}  
```

В этой части кода инициализируется точка входа в программу и выполняется метод `runApp`, который инициализирует Flutter-приложение и выполняет подключение виджета `MyApp` к экрану.

**То есть:**
- Точка входа в программу такая же, как и у консольных приложений,
- Приложение инициализируется в `runApp`,
- В `runApp` происходит подключение дерева виджетов.

### Инициализация приложения

```dart
class MyApp extends StatelessWidget {  
  const MyApp({super.key});  
  
  @override  
  Widget build(BuildContext context) {  
    return MaterialApp(  
      title: 'Flutter Demo',  
      theme: ThemeData(  
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),  
        useMaterial3: true,  
      ),  
      home: const MyHomePage(title: 'Flutter Demo Home Page'),  
    );  
  }  
}
```

Как можно заметить, `MyApp` наследуется от `StatelessWidget`.  Забегая вперед, всего существует три базовых типа виджетов: `Stateless`, `Stateful`, `Inherited` – мы поговорим о них чуть позже.

`StatelessWidget` – это виджет не имеющий собственного состояния, он конфигурируется лишь единожды при подключению к дереву виджетов (при вызове метода build). То есть, виджеты этого типа не предоставляют возможность переконфигурации или переотрисовки. Зато он отлично подходит для декомпозиции UI на логические части.

Например, в данном случае в `MyApp` инициализируются базовые настройки приложения:

**`MyApp`**
- **`MaterialApp`**
	- Название приложения
	- Стили и цветовая палитра приложения
	- **`MyHomePage`**
		- Название страницы

**То есть:**
- `MyApp` является `StatelessWidget`,
- `MyApp` выделяет описание параметров приложения в отдельную логическую часть. 

## Инициализация главного экрана

```dart
class MyHomePage extends StatefulWidget {  
  const MyHomePage({super.key, required this.title});  
  final String title;  
  
  @override  
  State<MyHomePage> createState() => _MyHomePageState();  
}  
  
class _MyHomePageState extends State<MyHomePage> {  
  int _counter = 0;  
  
  void _incrementCounter() {  
    setState(() {  
      _counter++;  
    });  
  }  
  
  @override  
  Widget build(BuildContext context) {  
    return Scaffold(  
      appBar: AppBar(  
        backgroundColor: Theme.of(context).colorScheme.inversePrimary,  
        title: Text(widget.title),  
      ),  
      body: Center(  
        child: Column(  
          mainAxisAlignment: MainAxisAlignment.center,  
          children: <Widget>[  
            const Text(  
              'You have pushed the button this many times:',  
            ),  
            Text(  
              '$_counter',  
              style: Theme.of(context).textTheme.headlineMedium,  
            ),  
          ],  
        ),  
      ),  
      floatingActionButton: FloatingActionButton(  
        onPressed: _incrementCounter,  
        tooltip: 'Increment',  
        child: const Icon(Icons.add),  
      ),  
    );  
  }  
}
```

`MyHomePage` описывает главную страницу приложения. В отличие от `MyApp`, `MyHomePage` наследуется от `StatefulWidget`. 

`StatefulWidget` –  это виджет, имеющий собственное состояние. Для унификации логики работы с виджетами его состояние вынесено в отдельный класс. Мы можем управлять этим состоянием, что повлечет за собой переконфигурацию и перерисование экрана.

В данном случае, экран выглядит так:

![](../../_assets/png/Снимок%20экрана%202024-11-07%20в%2018.10.13.png)

Как мы видим, по нажатию на кнопку "+" значение на экране увеличивается на единицу. За это отвечает метод `setState`, который маркирует экран, как необходимый для пересборки. В следующем же фрейме Flutter перерисует экран в соответствие с изменениями. Перерисовывается как экран, так и все дочерние виджеты, конфигурация которых поменялась (Например, текст, в который передали новое значение).

**`MyHomePage`**
- **`_MyHomePageState`**
	- Состояние counter
	- Метод для увеличения counter и обновления состояния
	- **`Scaffold`**
		- **`AppBar`**
			- Цвет верхней панели
			- **`Text`**
				- Текст названия
		- **`Center`**
			- **`Column`**
				- Alignment списка
				- **`Text`**
					- You have pushed the button this many times
				- **`Text`**
					- Актуальное значение counter
					- Стиль текста
					- (Перерисовывается при обновлении состояния!)
		- **`FloatingActionButton`**
			- Обработка нажатия
			- Текст всплывающей подсказки
			- **`Icon`**
				- Задание иконки

**То есть:**
- `MyHomePage` является `StatefullWidget`,
- `MyHomePage` выделяет экран в отдельную логическую часть,
- `MyHomePage` может вызвать собственную перерисовку себя и своих дочерних виджетов.

### Выводы
Мы разобрали базовый пример Flutter приложения, поняли из чего оно состоит и усвоили ключевые концепции.
# 2.2.  Построение экрана

Как уже было упомянуто, всего существует три базовых типа виджетов: `Stateless`, `Stateful`, `Inherited`.

## Stateless

`StatelessWidget` — виджет, не имеющий состояния. Он позволяет декомпозировать UI.

Чтобы создать собственный `StatelessWidget`, можно использовать сниппет `stless` (работает в IDE с установленным плагином Flutter, который создаст следующий класс:

```dart
class SomeWidget extends StatelessWidget { 
	const SomeWidget({Key? key}) : super(key: key); 
	
	@override 
	Widget build(BuildContext context) { 
		return const Placeholder(); 
	} 
}
```

Как видите, это просто класс, который наследуется от абстрактного класса `StatelessWidget` и реализует метод `build`. Из build-метода мы должны вернуть объект типа `Widget`.

Необязательный параметр конструктора `key` — уникальный идентификатор для `Widget`. Подробнее ключи будут рассмотрены в следующих параграфах. Сейчас мы примем за правило, что возможность передать ключ должна быть у любого виджета.

У build-метода есть аргумент `BuildContext context`. BuildContext — это интерфейс, который предоставляет виджету методы, чтобы взаимодействовать с деревом элементов. К контексту и элементам мы скоро вернёмся.

Теперь давайте переделаем наш `Hello, World` с использованием `StatelessWidget`. Для этого необходимо создать наследник класса `StatelessWidget` и перенести виджет `Column` из функции `main` в метод `build`.

```dart
void main() {
  runApp(
    const HelloWidget(
      text: 'Hello, I am StatelessWidget!',
    ),
  );
}

class HelloWidget extends StatelessWidget {
  final IconData icon;
  final String text;

  const HelloWidget({
    required this.text,
    this.icon = Icons.bolt,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Icon(
          icon,
          size: 32,
          textDirection: TextDirection.ltr,
        ),
        Text(
          text,
          textDirection: TextDirection.ltr,
        ),
      ],
    );
  }
}
```

Обратите внимание, что мы использовали final-поля в `StatelessWidget`, чтобы передать параметры извне. В нашей задаче это было вовсе не обязательно, но такой подход часто используется, когда мы хотим управлять параметрами или поведением виджета.
## Жизненный цикл

`StatelessWidget` во Flutter представляет собой виджет, который не изменяется после создания. Его жизненный цикл довольно простой, так как он не содержит состояния и не обновляется после первоначальной сборки. Вот основные этапы жизненного цикла `StatelessWidget`:

1. **Создание (Constructor)**: 
   Конструктор `StatelessWidget` вызывается, когда виджет создается. На этом этапе инициализируются все переменные, которые передаются в виджет. Виджет получает все необходимые данные и зависимости через конструктор.

2. **Сборка (build)**:
   Метод `build` вызывается для отрисовки `StatelessWidget`. В этом методе виджет определяет, как он должен отображаться на экране, возвращая дерево других виджетов. Это единственный метод жизненного цикла, который должен быть реализован для `StatelessWidget`. Когда `build` вызывается, Flutter генерирует дерево виджетов и отображает его на экране.

3. **Удаление (Dispose)**:
   Хотя `StatelessWidget` не имеет состояния, его также может быть нужно удалить, если родительский виджет меняется или если само дерево виджетов перестраивается. Однако `StatelessWidget` не имеет явного метода `dispose`, поскольку он не содержит ресурсов, которые нуждаются в освобождении или очистке.

### Основные моменты жизненного цикла:
- `StatelessWidget` создается только один раз и больше не обновляется, если его свойства не изменяются.
- Если Flutter обнаруживает необходимость обновления, `StatelessWidget` будет полностью пересоздан, а не обновлен как `StatefulWidget`.
- Поскольку `StatelessWidget` не хранит состояния, его проще использовать и тестировать, особенно в ситуациях, где виджет зависит исключительно от входных данных.

Таким образом, жизненный цикл `StatelessWidget` в основном сводится к выполнению конструктора и метода `build`.

### 1.1.4. Stateful


### 1.1.5. Inherited


# 2. Базовые виджеты
## 2.1. Готовые виджеты Flutter
### 2.1.1. Material
### 2.1.2. Cupertino

## 2.2. Layouts
### 3.1. Управление компоновкой
### 3.2. Контейнеры

# 4. Под капотом
## 4.1. Три основных дерева
### 4.1.1. Обзор
### 4.1.1. Widget
### 4.1.1. Element
### 4.1.1. RenderObject

## 4.2. Потоки приложения
## 4.3. Работа с платформой

# 5. Ресурсы

# 6. Зависимости